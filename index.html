
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>スマホアプリの設計と開発</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="./codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id=""
                  title="スマホアプリの設計と開発"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="はじめに" duration="0">
        <h2 is-upgraded>本書の内容</h2>
<p>本書では、データモデル設計とNoSQLデータベースとFirestoreについて学んだのち、レストランにレビューを追加するアプリを例にFirebaseとFlutterを使ったスマホアプリ開発する一連の流れをハンズオンします。</p>
<h2 is-upgraded>本書のコンセプト</h2>
<p>最近はコロナの影響もあり、在宅勤務が推奨され、学校の授業がオンライン化され、買い物はeコマースの利用が増加し、食事の際も出前アプリを使った配達が流行っています。コロナ以前も社会へのオンライン化の必要性が謳われていましたが、コロナ渦ではあらゆる生活の場面で半強制的にオンライン利用が義務化されたため、ますます使いやすいオンラインサービスに対する需要が増しています。</p>
<p>最近のシステム開発の動きを見ると、いままで使いづらいサービスの代名詞であった行政や金融のオンラインサービスをユーザ中心設計を採用し、使いやすくセキュリティ上も安全なサービスに作り替えようとする取組が進められています。またIT化が比較的遅れていた中小企業においてもDX（デジタルトランスフォーメーション）を促進しようとする動きがあります。</p>
<p>あらゆる業界・組織において、あらゆる生活シーンでそれぞれの要件にあった使いやすいオンラインサービスが安価に構築・提供されることが求められています。</p>
<p>一方これらの要望を担う人材育成の観点では、子供から大人までプログラミング教育がはやっており、文科省は小学校でのプログラミング授業を必須化しています。</p>
<p>ただし、システム開発や人材育成において下記のような課題があると感じています。</p>
<ul>
<li>アプリ開発の要件定義や設計フェーズにおいて画面設計に走りがちで、データ構造やロジックの設計がおろそかになり、プログラマーが開発をはじめらずプロジェクトが遅延するといった状況に陥りがちです。20年近くIT企業でアプリ開発を実施してきましたが、昔も今もこのようなプロジェクトをいくつか見ています。</li>
<li>この原因としては、システムデザインについての手法（ドメイン駆動設計やシステムアーキテクチャなど）やその説明が高尚で難しいという問題があります。そのため、本来必要なシステムデザインがスルーされ、スケジュールのプレッシャーもありとりあえず簡易な画面設計に走ることにつながるのではと感じています。</li>
<li>昨今のユーザ中心設計の誤った解釈から、システムの顧客接点である画面のデザインがフォーカスされ、発注側の要件定義担当者やデザイナーを含めたプロジェクトメンバーが、本来画面設計の元になるはずのデータモデリングについて理解が乏しいことに原因があるのではとも感じています。</li>
<li>例えば、業務で扱うデータが整理できておらず各業務ステップで担当者が手動で作業をしているため、残業が減らないのでシステム化で改善したい、といった要望がありました。ここではアーキテクト不在で要件定義が進められ、プロジェクトマネージャやデザイナが画面設計に走り、プロジェクトの半年後はじめからやりなおしになりました。システム化とは業務とデータの整理整頓でありデータモデリングがはじめから必要であることを意識しておくべきです。</li>
<li>エンジニア育成という観点からは、従来のプログラミングの学習コンテンツはプログラミング言語の文法を学ぶことが目標となっており、出来上がったプログラムが端末に&#34;Hello World&#34;と表示するといった面白みにかけ作りたいものからかけ離れた学習内容になっていることが多いです。そのため初心者の時点からやる気をなくしてしまいます。</li>
<li>最近の子供向けプログラミング授業用ソフトは使いやすい見た目がよく、マウス操作でプログラミングの論理的思考が学べるといったすぐれた面がある一方、汎用的なアプリケーションを開発するため使えないといった欠点も見受けられます。</li>
</ul>
<p>以上のことから、エンジニアだけでなく発注側顧客企業の担当者やプロジェクトマネージャもユースケースからデータモデルに落とす考え方やデータモデルから画面設計を行うための考え方、さらにはこれらのパターンを知っていることが望まれます。</p>
<p>そこで本書ではデータモデリングの具体的な方法と考え方についても詳しく説明するよう心がけました。またエンジニア育成という観点では、アイデアが浮かんだらすぐに完成品までもっていけるよう効率的で汎用的なツールを選び、それらのハンズオンを掲載しています。具体的な選定理由は以下の通りです。</p>
<ul>
<li>開発対象のアプリは昨今の利用シーンを考えスマホアプリを対象としました</li>
<li>サーバ構築には、スマホアプリに一般的に必要となるサーバ機能をボタン一つで提供するGoogle Cloud Firebaseを採用しました</li>
<li>認証のしくみには、スマホアプリに即組み込めて、様々なタイプの認証機能を提供し、外部のOIDCサーバとも連携できるFirebase Authを採用しました</li>
<li>データベースには、リアルタイムデータベースとスマホアプリから安全に直接アクセスできるSDKが提供されているFirestoreを採用しました。本来ならデータベース構築以外にもアプリをデータベースにつなげるためのAPI開発やセキュリティ対策も必要になりますが、Firestoreの採用によりこれらの工数が劇的に削減されます。</li>
<li>スマホアプリ開発には、一つのプログラミングコードでiPhoneアプリもAndroidアプリもWebアプリも構築できるクロスプラットフォームの一つであるFlutterを採用しました。本来ならiPhoneアプリ、Androidアプリ、Webアプリそれぞれについて、異なる開発環境、プログラミング言語、開発フレームワークを使った開発が必要ですが、これらを一つの環境で同一のプログラミング言語で一回コーディングすることで可能にしています。これにより開発工数が大幅に削減されます。</li>
</ul>
<p>様々な立場の人が本書を読んでハンズオンを試すことで、非エンジニアとしてものづくりをさけてきた人たちも「こんなに簡単に作れるんだ」とものづくりに興味をもってもらい、自分たちが実現したいシステムを自らが構築するといった好奇心をもっていただく一助になればと思っています。</p>
<p>※ 著者は2020年2月に第33回「21世紀交流サロン・葵丘」にてこれらの考え方について話しました。<a href="http://21cmikawa.jp/activity/activity.php" target="_blank">http://21cmikawa.jp/activity/activity.php</a></p>
<h2 is-upgraded>本書で学ぶこと</h2>
<ul>
<li>ユースケースを元にしたデータモデリング概要とパターン</li>
<li>NoSQLデータベースとCloud Firestoreの概要</li>
<li>Firebase AuthとFirestore、Cloud Functionsの使い方</li>
<li>Flutterを使ったアプリの開発</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="データモデル設計" duration="0">
        <p>データモデルの設計はユースケースからデータモデル候補を抜き出すことからはじめます。これによってデータの大きな単位とそこに含まれるフィールドを整理できます。また、ここで抽出されたデータ単位ごとにテーブルを作り、具体的なデータサンプルを作っておくと次ステップのデータ間の関係を考える際に役立ちます。</p>
<p>データ候補が抽出できたら、まとめたデータサンプルを参照しながらそれらの関係を整理します。本書ではドキュメント型データベースを採用するため、ドキュメントとコレクションの関係を整理します（ドキュメント型データベースについては、「NoSQLとFirestoreについて」を参考にしてください）。前ステップで行ったデータ候補の抽出は比較的簡単な作業ですが、ここで行うデータ間の関係整理は経験が必要な難しい作業です。前ページ「はじめに」で挙げた課題である画面設計に走りがちな理由もこの難しさにあるものと考えられます。次ページ「ユースケースとデータモデルのパターン」では、よくあるユースケースとデータモデルと画面設計のパターンをまとめていますので、興味がある方はそちらを参照ください。</p>
<p>コレクションとドキュメントの分離方針がきまったら、サンプルデータをJSONの形式にまとめます。JSONスキーマにそった正しいJSON形式にまとめることでドキュメント型データベースで扱えるサンプルデータが作成されます。JSONとはWebアプリケーションやREST APIで扱われるプログラムが処理しやすく人も見やすいデータ形式ですが、初めてJSONを扱う人は正しいJSON形式とは何かわからないと思います。そのため本書では本文中にJSONエディタというツールを組み込んでJSONデータを表示し、JSON形式でのサンプルデータの作り方をステップバイステップで解説します。</p>
<h2 is-upgraded>1. ユースケースからデータの候補を抽出する</h2>
<p>顧客がレストランに対して星の数とコメントでレビューを記入し公開するアプリを例にしたユースケースを以下にまとめます。</p>
<ol type="1" start="1">
<li>顧客はアプリにログインする</li>
<li>レストランのリストが表示され、料理の種類や住所、星の数の平均でソートや検索する</li>
<li>レストランのリストから一つを選ぶとレストランの詳細が表示する</li>
<li>レストランのリストから一つを選ぶとレストランの詳細が表示する</li>
<li>レストランの詳細には店名、料理の種類、住所、星の数の平均のほか、そのレストランに対するレビューがリスト表示され、星の数やコメントの内容でソートや検索をする</li>
<li>レストランの詳細ではそのレストランのレビューがリストされ、登録ができる</li>
<li>レビューでは星の数とコメントが登録でき、登録更新時にレストランの星の数の平均が更新される</li>
<li>レストランのレビューは顧客自身が登録したレビューについては編集と削除ができる</li>
</ol>
<p>ここから得られるデータ候補を「ドキュメント（フィールド1、フィールド2、‥）」と表現すると下記のように整理できます。</p>
<ul>
<li>レストラン（店名、料理の種類、住所、星の数の平均）</li>
<li>レビュー（レビュー者、レストラン、星の数、コメント）</li>
<li>顧客（メールアドレス、名前、アイコン）</li>
</ul>
<p>ここで具体的なサンプルデータを表形式にまとめておくとイメージしやすくなり今後の設計もしやすくなり、開発メンバーへの説明もしやすく開発やテスト等にも生かせます。</p>
<h3 is-upgraded>表1. レストラン</h3>
<table>
<tr><td colspan="1" rowspan="1"><p>ID</p>
</td><td colspan="1" rowspan="1"><p>名前</p>
</td><td colspan="1" rowspan="1"><p>種類</p>
</td><td colspan="1" rowspan="1"><p>住所</p>
</td><td colspan="1" rowspan="1"><p>星</p>
</td><td colspan="1" rowspan="1"><p>ロゴ</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>ガスト東岡崎店</p>
</td><td colspan="1" rowspan="1"><p>洋食</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市大西１丁目１−１０</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://www.skylark.co.jp/site_resource/gusto/images/logo.svg</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1</p>
</td><td colspan="1" rowspan="1"><p>デニーズ東岡崎店</p>
</td><td colspan="1" rowspan="1"><p>洋食</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市美合町 字五反田２５－１</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://sozainavi.com/wp-content/uploads/2019/10/dennys.jpg</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>2</p>
</td><td colspan="1" rowspan="1"><p>大戸屋ごはん処岡崎店</p>
</td><td colspan="1" rowspan="1"><p>和食</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市井田西町１−１１</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://sozainavi.com/wp-content/uploads/2019/10/ootoya.jpg</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>3</p>
</td><td colspan="1" rowspan="1"><p>和食さと岡崎店</p>
</td><td colspan="1" rowspan="1"><p>和食</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市上里２丁目１−１</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://sato-res.com/assets/tile/sato.png</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>4</p>
</td><td colspan="1" rowspan="1"><p>カレーハウスCoCo壱番屋岡崎上地店</p>
</td><td colspan="1" rowspan="1"><p>カレー</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市上地３丁目５１−６</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://www.ichibanya.co.jp/assets/images/common/ogp.png</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>5</p>
</td><td colspan="1" rowspan="1"><p>スシロー岡崎上和田店</p>
</td><td colspan="1" rowspan="1"><p>寿司</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市天白町東池１５−１</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://www.akindo-sushiro.co.jp/shared/images/ogp.png</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>6</p>
</td><td colspan="1" rowspan="1"><p>くら寿司北岡崎店</p>
</td><td colspan="1" rowspan="1"><p>寿司</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市錦町２−１２</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://www.watch.impress.co.jp/img/ipw/docs/1230/499/kura1_s.jpg</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>7</p>
</td><td colspan="1" rowspan="1"><p>モスバーガー岡崎大西店</p>
</td><td colspan="1" rowspan="1"><p>ハンバーガ</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市大西１丁目１６−７</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>http://www.wing-net.ne.jp/image/kamiooka/store/storage/w250/mos.png</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8</p>
</td><td colspan="1" rowspan="1"><p>マクドナルド岡崎インター店</p>
</td><td colspan="1" rowspan="1"><p>ハンバーガ</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市大平町石丸６０−１</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://sozainavi.com/wp-content/uploads/2019/10/mcdonalds.png</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>9</p>
</td><td colspan="1" rowspan="1"><p>かつや愛知岡崎インター店</p>
</td><td colspan="1" rowspan="1"><p>とんかつ</p>
</td><td colspan="1" rowspan="1"><p>愛知県岡崎市大平町新寺25</p>
</td><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>https://www.arclandservice.co.jp/katsuya/wp-content/themes/arclandservice-group/assets/img/katsuya/common/logo.svg</p>
</td></tr>
</table>
<h3 is-upgraded>表2. レビュー</h3>
<p>レストラン「ガスト東岡崎店」に対するレビュー</p>
<table>
<tr><td colspan="1" rowspan="1"><p>ID</p>
</td><td colspan="1" rowspan="1"><p>顧客名</p>
</td><td colspan="1" rowspan="1"><p>星</p>
</td><td colspan="1" rowspan="1"><p>コメント</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>鈴木一郎</p>
</td><td colspan="1" rowspan="1"><p>2</p>
</td><td colspan="1" rowspan="1"><p>値段の割に合わない気がする。</p>
<p>チーズハンバーグを頼んだが、レトルトな感じでした。</p>
<p>さらに、スープセットにしたが、スープは一種類。</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1</p>
</td><td colspan="1" rowspan="1"><p>佐藤二郎</p>
</td><td colspan="1" rowspan="1"><p>3</p>
</td><td colspan="1" rowspan="1"><p>タブレットによる注文に変わったが、慣れが必要。</p>
<p>メニューを広げて、料理を比べたい。</p>
<p>この方式で価格が下がればよいが、，，</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>2</p>
</td><td colspan="1" rowspan="1"><p>北島三郎</p>
</td><td colspan="1" rowspan="1"><p>5</p>
</td><td colspan="1" rowspan="1"><p>ドリンクバーが99円(単品で注文してもOK)。</p>
<p>パソコンの持ち込みOK。</p>
<p>コンセントで充電できる。持ち帰り容器は無料。</p>
<p>食べきれない料理の持ち帰りOK。</p>
<p>トイレは新しくてキレイ</p>
</td></tr>
</table>
<h3 is-upgraded>表3. 顧客</h3>
<table>
<tr><td colspan="1" rowspan="1"><p>ID</p>
</td><td colspan="1" rowspan="1"><p>メールアドレス</p>
</td><td colspan="1" rowspan="1"><p>名前</p>
</td><td colspan="1" rowspan="1"><p>アイコン</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>ichiro@test.com</p>
</td><td colspan="1" rowspan="1"><p>鈴木一郎</p>
</td><td colspan="1" rowspan="1"><p>https://meikyu-kai.org/wp-content/uploads/2020/01/51_Ichiro.jpg</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1</p>
</td><td colspan="1" rowspan="1"><p>jiro@test.com</p>
</td><td colspan="1" rowspan="1"><p>佐藤二郎</p>
</td><td colspan="1" rowspan="1"><p>http://www.from1-pro.jp/images/t_10/img_l.jpg?1597426029</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>2</p>
</td><td colspan="1" rowspan="1"><p>saburo@test.com</p>
</td><td colspan="1" rowspan="1"><p>北島三郎</p>
</td><td colspan="1" rowspan="1"><p>https://cdn.asagei.com/asagei/uploads/2016/08/20160810kitajima.jpg</p>
</td></tr>
</table>
<h2 is-upgraded>2. データをドキュメントとコレクションのツリー構造にする</h2>
<p>1で抽出したデータをドキュメントとコレクションのツリー構造にします。</p>
<ol type="1" start="1">
<li>レストランドキュメントと顧客ドキュメントはルートレベルコレクションに納める</li>
<li>レビュードキュメントはレストラン・ドキュメントのサブコレクションに納める</li>
<li>レビュードキュメントに顧客フィールドの一部をマップとして納める</li>
</ol>
<p class="image-container"><img style="width: 591.38px" src="img/392308f2014e0d18.png"></p>
<h2 is-upgraded>3. サンプルデータをJSON形式で表現する</h2>
<p>ドキュメントとそのフィールド、コレクションとそれらの関係について方針が決まったら、より具体化するために1のサンプルデータを作ってJSON形式で表現していきます。ここではJSONエディタを使い、ステップバイステップでサンプルデータを作成していきます。</p>
<aside class="warning"><p><strong>ノート: </strong>JSONエディタを使うと直感的にJSON形式のデータを作成、編集することができます。操作方法は下記の通りです。</p>
<p>1. 表示形式を下記の通り変更できます。</p>
<p>「Code」を選ぶとJSONの生データの形式で表示されます。</p>
<p class="image-container"><img style="width: 396.50px" src="img/889d519c5f591478.png"></p>
<p>「Tree」を選ぶとJSONデータを解釈したツリーが表示されます。</p>
<p class="image-container"><img style="width: 397.50px" src="img/b329e5204edbb65f.png"></p>
<p>「Tree」表示でヘッダ部分の左から1つめのアイコン<img style="width: 20.00px" src="img/b9c283c10a282add.png">を選ぶと閉じていたツリー全体を開けます。その右のアイコンでツリー全体を閉じます。</p>
<p class="image-container"><img style="width: 402.29px" src="img/4a990977802676bd.png"></p>
<p>2. 編集する際は「Code」表示にして行います。JSON形式にエラーがあるとエディタの左部分に「✖️」が表示されるので指示に従って修正します。</p>
</aside>
<h4 is-upgraded><strong>3-1. レストラン・ドキュメントの作成</strong></h4>
<p>上記表1のIDが0のレコードを参考にレストラン・ドキュメントを作成します。</p>
<iframe width="820" height="220" src="./json01.html" frameborder="1"></iframe>
<p>JSONではデータのひとつの塊であるドキュメントを { } で囲み、その中に &#34;属性名&#34;: &#34;属性値&#34; をカンマ（ , ）で区切ってリストします。</p>
<h4 is-upgraded><strong>3-2. レストラン・コレクションの作成</strong></h4>
<p>上記表1の通りレストランは10個存在するため、配列をあらわすコレクションとして表現します。</p>
<iframe width="820" height="420" src="./json02.html" frameborder="1"></iframe>
<p>JSONではこのコレクションを { &#34;配列名&#34;: [(ドキュメントをカンマ( , )で区切ってリスト)] } で表現します。</p>
<h4 is-upgraded><strong>3-3. 顧客コレクションの追加</strong></h4>
<p>レストランと同じく顧客コレクションもルートレベルに追加します。</p>
<iframe width="820" height="420" src="./json03.html" frameborder="1"></iframe>
<p> JSONでは二つのコレクションを { &#34;restaurants&#34;: [(...)], &#34;users&#34;: [(...)] } と表現します。 </p>
<h4 is-upgraded><strong>3-4. レビュー・ドキュメントをレストラン・ドキュメント配下のサブコレクションとして追加</strong></h4>
<p>レビュー・ドキュメントの配列であるコレクションをレストラン・ドキュメント配下に追加します。この時、レビュー・ドキュメントには書き込みを行った顧客がわかるように顧客IDを追加します（レビュー・ドキュメントはレストラン・ドキュメント配下のサブコレクションに含まれるため、レストランIDは必要ありません）。また、レビュー・ドキュメントから書き込みを行った顧客名とレビュー対象のレストラン名がわかるようそれらの項目も追加します。これらの作業の必要性は「NoSQLとFirestoreについて」を参照してください。</p>
<iframe width="820" height="620" src="./json04.html" frameborder="1"></iframe>


      </google-codelab-step>
    
      <google-codelab-step label="ユースケースとデータモデルのパターン" duration="0">
        <p>世にあるアプリのユースケースをいくつか例に挙げ、それらのデータモデルと画面設計のパターンを紹介します。これらを理解し参考にすることで、経験の少ない方でもみずからのユースケースを整理して、正しくアプリの設計を行うことが可能になるでしょう。</p>
<h2 is-upgraded>1. メモアプリ</h2>
<p>TODO</p>
<h3 is-upgraded>1-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>1-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>1-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>2. 学生名簿</h2>
<p>TODO</p>
<h3 is-upgraded>2-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>2-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>2-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>3. 観光地紹介</h2>
<p>TODO</p>
<h3 is-upgraded>3-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>3-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>3-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>4. カレンダー</h2>
<p>TODO</p>
<h3 is-upgraded>4-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>4-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>4-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>5. 会議室予約</h2>
<p>TODO</p>
<h3 is-upgraded>5-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>5-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>5-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>6. 商品購入</h2>
<p>TODO</p>
<h3 is-upgraded>6-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>6-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>6-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>7. 出前</h2>
<p>TODO</p>
<h3 is-upgraded>7-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>7-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>7-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>8. ホテル予約</h2>
<p>TODO</p>
<h3 is-upgraded>8-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>8-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>8-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>9. 高速バス予約</h2>
<p>TODO</p>
<h3 is-upgraded>9-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>9-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>9-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>10. 営業支援</h2>
<p>TODO</p>
<h3 is-upgraded>10-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>10-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>10-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>11. 保険契約管理</h2>
<p>TODO</p>
<h3 is-upgraded>11-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>11-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>11-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>12. 物品管理</h2>
<p>TODO</p>
<h3 is-upgraded>12-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>12-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>12-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>13. ホームページ管理</h2>
<p>TODO</p>
<h3 is-upgraded>13-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>13-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>13-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>14. 出張申請・精算</h2>
<p>TODO</p>
<h3 is-upgraded>14-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>14-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>14-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>15. グループチャット</h2>
<p>TODO</p>
<h3 is-upgraded>15-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>15-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>15-3. 画面設計</h3>
<p>TODO</p>
<h2 is-upgraded>16. ポイント管理</h2>
<p>TODO</p>
<h3 is-upgraded>16-1. ユースケース</h3>
<p>TODO</p>
<h3 is-upgraded>16-2. データモデル</h3>
<p>TODO</p>
<h3 is-upgraded>16-3. 画面設計</h3>
<p>TODO</p>


      </google-codelab-step>
    
      <google-codelab-step label="NoSQLとFirestoreについて" duration="0">
        <p>Googleが公開している12コマの動画シリーズをベースにNoSQLデータベースとFirestoreを解説します。</p>
<h2 is-upgraded>動画の全体像</h2>
<p>ここで紹介する動画シリーズは、GoogleのTodd Kerpelman氏による「<a href="https://www.youtube.com/playlist?list=PLl-K7zZEsYLluG5MCVEzXAQ7ACZBCuZgZ" target="_blank">Get to know Cloud Firestore</a>」という動画シリーズで、Firestoreを使い始めるにあたって知っておくべきことを12回にわたって解説しているものです。本書に添付された動画は全画面表示が可能ですし、英語の字幕を自動表示する設定になっていますが、英語が苦手な人はYoutube画面の右下の設定で字幕をONにし、さらに字幕の自動翻訳を選び日本語を選択して日本語字幕を表示することも可能です。</p>
<h2 is-upgraded>1. NoSQLの特徴</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/v_hR4K4auoQ?cc_load_policy=1<p>v_hR4K4auoQ</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>従来型のリレーショナルデータベースではテーブルのスキーマが厳格に定義され、正規化という手法でデータの重複が発生しないようテーブル分割します。分割されたテーブルが互いに関係を持つ場合、一方のプライマリキーを他方が外部キーとして持つことで1対多の関係を構成します。例えば「レストラン」と「顧客」と「顧客によるレストランのレビュー（以下「レビュー」）」の3テーブルあるとして「レビュー」は「レストラン」と「顧客」を外部キーとして持つことで「レビュー」テーブルが「レストラン」と「顧客」の間の中間テーブルとして機能します。こうすることで、「レストラン」は「顧客」から0個以上の複数「レビュー」を受け、「顧客」は0個以上の複数「レストラン」に対して「レビュー」を行える、といった多対多の関係を表現することができるわけです。</li>
</ul>
<p class="image-container"><img style="width: 549.00px" src="img/ffa6d83682381ec7.png"></p>
<ul>
<li>一方、NoSQL型データベースには様々なタイプがあるものの、主に「スキーマレス」という特徴を持ち、テーブル定義のような厳格なスキーマをあらかじめデータベース側に定義する必要はありません。ただし、NoSQL型データベースでも上記のようなテーブル間のリレーションは重要概念で、クライアントアプリ側のデータベースアクセス部分（いわゆるCRUD操作する部分）を正しく開発するためにテーブル間の関係を設計する必要があります。しかし「スキーマレス」の特徴のため、アプリのリリース後にテーブルに新たなフィールドを追加したくなった場合はアプリの修正だけで対応が可能で、リレーショナルデータベースの時代のようにデータの移行を考慮しながらデータベースに対してスキーマ定義を更新するといった作業が必要ないといった利点があります。</li>
<li>またNoSQL型データベースにはSQL文がありません。例えばコレクションとドキュメントのツリー構造からなるドキュメント型データベースでは、ドキュメントの階層をたどって検索を行うことで目的のドキュメントにたどりつくといったしくみでデータ操作を行います。そのため、リレーショナルデータベースでは正規化してきれいにテーブル分離する一方、同時に頻繁に検索対象となりうるフィールドをあえて親子のドキュメント間で重複して持つといった非正規化を行い、一つの検索で目的の情報にたどりつけるようにすることが、ドキュメント型データベースにおいては推奨されることがあります。例えば、レストランのレビューをリスト表示する場合で考えると、レビューにそれを行った顧客の名前フィールドをのせておくといったことです。こうすることで、レビューに登録された顧客IDから顧客ドキュメントを検索し、顧客の名前までたどるといった処理が必要なくなります。</li>
<li>ただしデータの重複保存は、表示の際の検索回数を削減できますが、データの一貫性を失わせます。重複しているフィールドの更新や削除の際、重複して保存された箇所すべての更新や削除を行うことを忘れないよう注意が必要です。これらデータの重複保存の設計は、参照の頻度と更新や削除の頻度のトレードオフを考慮して行います。</li>
<li>以上のとおり、リレーショナルデータベースとNoSQL型データベースにはそれぞれ利点と欠点がありますが、NoSQL型データベースの大きな利点として水平スケーリングが可能ということが挙げられます。この特徴により、アプリが人気になりデータアクセス数やデータ量が大きく増加した場合、NoSQLだとサーバの数を増強するだけで対応（これを水平スケールという）でき、サーバのコピーによる自動スケールが可能となり、運用保守の人件費やシステムの停止リスクが削減できます。</li>
<li>いままでデータベースにおいてもっとも大切と言われてきたデータの一貫性担保を一部犠牲にしたとしても、このようなクラウド時代においてNoSQLデータベースが求められる背景には、スケーラビリティへの要望やスキーマレスによる変更への柔軟に対応できるといったメリットが挙げられます。</li>
<li>Cloud Firestoreでは、NoSQL型データベースの中でもドキュメント型データベースを採用しています。ドキュメント型データベースでは、コレクションとドキュメントのツリー構造で構成され、JSONの配列とオブジェクトで表現することができます。これらコレクションとドキュメントの説明は、<a href="https://cloud.google.com/firestore/docs/data-model?hl=ja" target="_blank">Firebaseのデータモデル</a>を参照してください。</li>
</ul>
<h2 is-upgraded>2. クエリによる検索</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/Ofux_4c94FI?cc_load_policy=1<p>Ofux_4c94FI</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>データベースに検索を行ってデータを取得する操作のことをクエリと呼びます。一般的なドキュメント型データベースでは、一回のクエリの検索対象となるデータの範囲は検索対象ドキュメントが所属するコレクション内のみになります。以前に説明したコレクションとドキュメントの関係を思い出してもらいたいのですが、コレクションはドキュメントを含みますが、ドキュメントに直接ドキュメントを紐づけることはできず、必ずコレクションを挟みます。例えばレストランのレビューのケースのレストランとレビューの関係は下図のようになります。</li>
</ul>
<p class="image-container"><img style="width: 591.38px" src="img/a9e271f6dcff33fb.png"></p>
<ul>
<li>ここで注目してもらいたいのが各レビュー・コレクションはそれぞれのレストラン・ドキュメントに紐づいているので、すべてのレビューを対象に例えば星4以上など星の数を指定して一括検索することができません。この理由としては、NoSQLデータベースの特徴と言えますが、上のようなツリー構造のため、ドキュメントのインデックスはドキュメントを含むコレクション単位で作成されるためです。そのため、同じレビューだからといって隣のコレクションも含めて検索しようとしてもそれは対象外となってしまうわけです。同一名のコレクションを横断的に検索することはSQLではできたことで、レビュー・テーブルは正規化により一つだけ存在し、インデックス化もまとめて行われているのがそれができる理由です。</li>
<li>横断的な検索を可能にするため、Firestoreではコレクショングループという機能を用意しています。サブコレクション（上図のレビュー・コレクションに相当）において検索キーとして機能させたいフィールド（上図では「星の数」フィールド）を指定することでコレクション・グループ検索が可能になります。ただし、このコレクショングループに指定するフィールド数が増えれば増えるほどデータ更新時にインデックス処理がたくさん走るため更新に時間がかかってしまうこと、またFirestoreではコレクション・グループに指定できるフィールド数が200個までという制限があります。また、Firestoreデータベースツリー内に同一名のコレクションが複数あると、それら全てを含めてインデックス化してしまうことに注意が必要です。そのため、一つのFirestoreデータベースで利用するコレクション名は重複しないよう設計しましょう。</li>
<li>Firestoreはドキュメント内のすべてのフィールドが（マップ内のフィールドも含めて）自動的にインデックス化されるので、値の全文一致や上方一致、数値の大小で検索することは非常に高速で行えます。一方、SQL文の&#34;LIKE %(値)%&#34;のような部分一致を行う機能を持っておらず、下記のリンクのような工夫が必要です。<a href="https://qiita.com/oukayuka/items/d3cee72501a55e8be44a" target="_blank">https://qiita.com/oukayuka/items/d3cee72501a55e8be44a</a></li>
<li>またFirestoreの別の制限として&#34;!=&#34;が含まれるクエリや論理ORのクエリを行うことができません。例えば、星の数が満点5であるが書き込み数が少ないとフェイクかもしれないので、それらを除外する検索条件として「星の数が4以上5より少ない、もしくは、星の数が5でレビュー数が3以上のレビュー」を検索したいとしてもFirestoreではそれができません。そのため「星の数4以上5より小さいレビュー」と「星の数5でレビュー数が3以上」を検索して、クライアント側でマージして、重複データがあればクライアント側でそれを差し引きしなければなりません。もしくはこの検索条件を見越して新しいフィールド「満点疑惑」といったものを追加して、レビュー書き込み時に星の数5でレビュー数2以下の場合「満点疑惑」の値を疑惑があるといういみで「true」に設定し、検索時には星の数が4以上かつ「満点疑惑」が「false」を検索するようAND条件で検索できるよう工夫する必要があります。</li>
<li>さらにFirestoreのクエリで注意が必要なケースとして「複合クエリ」が挙げられます。複合クエリとはwhere文を複数つないでAND検索を行うことをあらわしますが、このとき複数種類のフィールドで範囲比較（&#34;&lt;&#34;, &#34;&lt;=&#34;, &#34;&gt;&#34;, &#34;&gt;=&#34;）やarray-contains句（配列に値を含むかという意味）を適用する場合は、それら複数フィールドの組み合わせでインデックスを作成しておく（これを複数インデックスと呼ぶ）必要があります。Firestoreのデフォルト機能としてあらかじめドキュメントのすべてのフィールドの組み合わせで複合インデックスを作っておくという案も考えられますが、これらの組み合わせ数は莫大な数になりうるため、検索の要件にあわせて複合インデックスを行うことになっています。</li>
<li>Firestoreの便利な機能としては、もしこの複合インデックスの設定がない状態でクライアントから複合クエリを実行した際、エラーメッセージとともにFirestore上の複合インデックス作成画面へのURIを返してくれるので、そのリンクをたどって設定を行い次からはエラーを回避することができます。</li>
<li>以上をふまえた上でFirestoreのクエリについてさらに確認したい場合は下記のオフィシャルドキュメントを参照してください。<a href="https://firebase.google.com/docs/firestore/query-data/queries" target="_blank">https://firebase.google.com/docs/firestore/query-data/queries</a></li>
</ul>
<h2 is-upgraded>3. コストの考え方</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/6NegFl9p_sE?cc_load_policy=1<p>6NegFl9p_sE</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>Firestoreでは、ドキュメントの読み込み数(10万回あたり0.06ドル)、ドキュメントの書き込み数(10万回あたり0.18ドル)、ドキュメントの削除数(10万回あたり0.02ドル)といったドキュメントの処理数単位で課金がなされます。</li>
<li>このような課金システムの場合、リスト画面の更新を行う際、リクエストレスポンス型のアクセスを行うと、データベース上のデータ更新部分が一部であったとして、更新されてないものも含め表示対象の全データをまとめて読み込むことになるのでコスト的に大変効率が悪くなります。このあとペジネーションのところで説明しますが、Firestoreでは、データアクセスをリアルタイムデータベースとのストリームとして扱い、クライアント側のキャッシュを有効利用して更新が発生したデータのみをやりとりします。これによって差分の読み書き分だけが課金され、全データ取得型より大幅にコストを削減することができます。</li>
<li>さらに、Google Cloud ConsoleのApp Engine画面にて、Firestoreの利用量と時間ごとの課金料金を確認することができます。また、利用料金の閾値を設けてそれを超えたらアラートメールを送ってくれるような設定を行うこともできるので、うまく運用保守で利用するとよいでしょう。</li>
</ul>
<h2 is-upgraded>4. マップと配列とサブコレクション</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/o7d5Zeic63s?cc_load_policy=1<p>o7d5Zeic63s</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 is-upgraded>Firestoreにおけるルール</h3>
<p>Firestoreでは、JSONの構造における配列（[]で表す）とマップ（{}で表す）をドキュメント型リアルタイム・データベースとしてうまく操作できるようコレクション（JSON内の配列に相当）とドキュメント（JSON内のマップに相当）にうまく分離して保存管理するよう設計します。この設計をうまく行うためにはFirestoreにおけるいくつかのルールを理解しておく必要があります。</p>
<h3 is-upgraded><strong>ルール1: ドキュメントには制約がある</strong></h3>
<ol type="1" start="1">
<li>ドキュメント1つあたり1MB制限あります。そのため、画像ファイルなど大きなファイルはFirebase firestorageに置きファイルパスをドキュメントに保存することで回避します。</li>
<li>ドキュメント1つあたり最大フィールド数は2万までの制限があります。普通1ドキュメントにそんなに大量のフィールドは必要ないでしょうが、例えばレストラン・ドキュメントにレビューデータも含めるといった設計にすると、有名なレストランではレビューデータが膨れ上がってこの制限を超えてしまうといったことがありえます。ドキュメント内のフィールドは書き込みや更新があるとその都度インデックス処理が走りますが、フィールド数が多すぎるとその処理にオーバーヘッドがかかってしまうという理由からもこの制約が設けられています。以上の理由からも、レビューのように1ドキュメントの配下に大量の配列がぶら下がるような構成の場合は、配列をコレクションとして分割するようにします。</li>
<li>ドキュメント1つあたり書き込み回数は1秒間に1回のみという制限があります。異なるドキュメントへの書き込みは並列処理されますが、同一ドキュメントへの複数からの同時書き込みは並列処理され1秒間に1回のみであり、同時に行われた書き込み処理は失敗するのでクライアント側で再試行する必要があります。</li>
</ol>
<h3 is-upgraded><strong>ルール2: 検索結果はドキュメント全体が出力される</strong></h3>
<ul>
<li>アプリ表示のときタイトルだけ欲しいケースがありますが、ドキュメント内の一部のフィールドだけを取得することはできず、全フィールドデータが送られてきます。これを回避したければドキュメントを分割する必要があります。</li>
<li>同じことはセキュリティルールにも言え、ドキュメント内の一部のフィールドだけ異なるアクセス権を付与するといった操作はできません。異なるセキュリティルールを設定したい場合、たとえドキュメント内で配列構造を持たない箇所でもコレクション配下の1ドキュメントとして分割して対応します。</li>
</ul>
<h3 is-upgraded><strong>ルール3: 検索対象は浅い</strong></h3>
<ul>
<li>一度のクエリでは、データベース全体でなくコレクション内のドキュメントだけが検索対象となります。そのためレビュー・リストに投稿した顧客名を表示したいような場合は、顧客ドキュメントの名前フィールドの情報をレビュー・ドキュメントにも用意する、といった非正規化が効果的となるでしょう。</li>
<li>2019年からコレクショングループの機能が追加され、「collectionGroud(&#34;コレクション名&#34;).where(...).getDocument)」といったクエリを使って子の情報から親を検索できるようになりました。</li>
</ul>
<h3 is-upgraded><strong>ルール4: 課金はドキュメントの読み書き回数でカウントされる</strong></h3>
<ul>
<li>Firestoreでは前述したとおりドキュメントの読み込みと書き込みの回数の合計で課金される金額が決まります。</li>
<li>ルール3のため、一度に表示したい情報が複数ドキュメントに分割されていると、一つにまとまっているよりも数倍の回数の読み込みが発生して課金が発生するので注意が必要です。</li>
<li>ただし、トランザクション数が少なく課金への影響が少額である部分の設計や実装にこだわるのは、設計者や開発者、運用者の人件費を考えると逆に無駄なことになりうることも念頭におき、ほどほどに設計するのがよいでしょう。</li>
</ul>
<h3 is-upgraded><strong>ルール5: 配列操作は奇妙である</strong></h3>
<ul>
<li>例えば、arr: [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]という配列は要素arr[1]を削除すると[&#39;a&#39;,&#39;c&#39;]に変わるが&#39;c&#39;に注目して考えるとarr[2]だったものがarr[1]に変わってしまいます。</li>
<li>配列要素に追加や削除があると、複数人でデータを扱う際一元的にデータ参照できないという問題があります。</li>
<li>解決策としては、ドキュメントはドキュメントIDを使って更新や削除を行うとよいでしょう。</li>
</ul>
<p>参考）<a href="https://firebase.googleblog.com/2014/04/best-practices-arrays-in-firebase.html" target="_blank">https://firebase.googleblog.com/2014/04/best-practices-arrays-in-firebase.html</a></p>
<h2 is-upgraded>5. データ構造</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/haMOUb3KVSo?cc_load_policy=1<p>haMOUb3KVSo</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>ドキュメント型データベースにおいて、ユースケースに適したデータ構造を設計するとき主に以下の3種類の構造から適切なものを選びます。</p>
<h3 is-upgraded><strong>タイプ1. ドキュメントの一部として配列もしくはマップとして含める</strong></h3>
<ul>
<li>例えば、レストラン・ドキュメントに最も星の数が多い5つのレビュー内容や最新の5つのレビュー内容をマップか配列として含めることも可能です。</li>
<li>利点としては、ドキュメントの一度の検索で表示すべき情報を取得することができることが挙げられます。</li>
<li>一方欠点としては、時間経過とともにフィールド数が増大し、更新時のインデックス処理に時間がかかるようになり、最終的には1ドキュメントあたり1MB制限や2万フィールド制限に到達してしまうことがあります。</li>
</ul>
<h3 is-upgraded><strong>タイプ2. オブジェクトをサブコレクションにおさめる</strong></h3>
<ul>
<li>例えば、レストランのレビューは大量の書き込みが行われる可能性もあるためレストラン・ドキュメントのサブコレクションに含めるとよいでしょう。</li>
<li>利点としては、リストが大きくなっても親ドキュメントのサイズが変わらず、複数のサブコレクションにまたがる検索をする場合は、<a href="https://cloud.google.com/firestore/docs/query-data/queries?hl=ja" target="_blank">コレクション グループ </a>を設定するとよいでしょう。</li>
<li>一方、欠点としては、ドキュメントをまたがって検索することが常である場合にも読み込み回数がドキュメント数分発生してしまうことが挙げられます。</li>
</ul>
<h3 is-upgraded><strong>タイプ3. オブジェクトをルートレベルのコレクションにおさめる</strong></h3>
<ul>
<li>例えば、レビューを書き込む顧客はこのアプリケーションのユーザであり、例えばアプリに出前機能が追加された際にも再利用する必要があるかもしれません。そういう意味でもルートレベルのコレクションとして整理するとよいでしょう。</li>
<li>利点としては、ルートレベルのコレクションはリレーショナルデータベースにおける正規化の考え方と同じく再利用しやすく、アプリの作り方によらずデータの一貫性が保たれ安心できます。</li>
<li>一方欠点としては、データが階層的になっていることから、データベースが拡大するにつれ、データの取得が難しくなる可能性があります。例えば、20才未満の顧客が4以上の星をつけたレストランを検索するのは簡単ではないので、必要となりそうな検索条件にあわせてレビュー・ドキュメントにも重複して顧客情報を持つよう設計するとよいでしょう。</li>
<li>データ構造については、下記のオフィシャル・ドキュメントも参照するとよいでしょう。</li>
</ul>
<p><a href="https://cloud.google.com/firestore/docs/concepts/structure-data?hl=ja" target="_blank">https://cloud.google.com/firestore/docs/concepts/structure-data?hl=ja</a></p>
<h2 is-upgraded>6. セキュリティルール</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/eW5MdE3ZcAw?cc_load_policy=1<p>eW5MdE3ZcAw</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>Firestoreでは、データベースのツリー構造のドキュメント位置を指定して誰がCRUD（Create:作成、Read:読み込み、Update:更新、Delete:削除）できるかを指定します。これらのアクセス権の指定はセキュリティルールといい、拡張子&#34;.rules&#34;のファイルに設計してFirestoreにデプロイして適用します。</li>
<li>データベース内で、フィールドレベルのアクセス権をIF文を使った複雑な条件文と共に直感的にルール化できるのは、リレーショナルデータベースにはない機能です。APIの開発をしなくてもクライアントから共通化されたSDKを使ってリアルタイムデータベースとしてアクセスできる、といったことを含めて、Firestoreはモバイル開発に最適なデータベースのひとつであると言えるでしょう。</li>
<li>このセキュリティルールでは、データベースのルートからのドキュメントへのパスを指定し、ドキュメントは{xxID}や{xxID=**}のようにID名（自由に命名できます）とワイルドカードを使って指定します。ここで{}内で指定した変数名(xxID)はドキュメントをあらわし、そのドキュメントに含まれるフィールドをキーにしてIF文の中でアクセス条件を指定することができます。またルールの中では「get(ドキュメントへのパス)」を指定して、指定したドキュメントのフィールド値にもアクセスできます（例えばログインユーザのロールなど）。</li>
<li>これらのルールは複雑で再利用したくなる場合がありますが、カスタムファンクションという関数を定義して、例えばGoogleアカウントかどうかをチェックするといった処理を関数化してルールファイル内で再利用することができます。</li>
<li>セキュリティルールはアクセス権の設定が主な目的ですが、このしくみを使うと書き込みや更新時に空白を受け付けないフィールドを指定したり、メールアドレスの形式のチェック、さらには1顧客が書き込みできるレビューの数を100件までに制限するといったデータバリデータとして利用することも可能です。そのため、プロジェクトごとにどこまでセキュリティルールに設定を行うかをあらかじめ決めておくとよいでしょう。</li>
<li>ルールファイルはアプリ内で想定通り動作することを担保するために単体テストを自動化するよいでしょう。その場合、Firebaseエミュレータを使ってテストすることをおすすめします。そうすれば、自動テストのために課金が発生するといったことを避けられます。</li>
<li>セキュリティルールについては、下記のオフィシャル・ドキュメントも参照するとよいでしょう。</li>
</ul>
<p><a href="https://cloud.google.com/firestore/docs/security/get-started" target="_blank">https://cloud.google.com/firestore/docs/security/get-started</a></p>
<p><a href="https://firebase.google.com/docs/reference/security/database" target="_blank">https://firebase.google.com/docs/reference/security/database</a></p>
<h2 is-upgraded>7. データのペジネーション</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/poqTHxtDXwU?cc_load_policy=1<p>poqTHxtDXwU</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>一般的に、アプリケーションが表示に必要なレコード以上のデータを取得すると無駄な読み込みに課金が発生し、ネットワークを流れるデータ量も増えるため、サーバ側でペジネーションを行うことが推奨されます。</li>
<li>Firestoreではストリーミング・データベースとして機能し、高度なペジネーション機能を提供します。というのも、クライアントとストリーミングとしてコネクションを維持している場合、常にクライアント側のキャッシュとの差分をチェックして更新分だけをやりとりしてくれる機能を持っています。また、リストを表示する画面があったとして、画面に表示されていない表の下部や上部をスクロール操作で表示したいとき、リアルタイムデータベースはスクロール操作にあわせて必要なデータをストリーム取得してくれます。</li>
<li>具体的には「Query.start(after:previousDoc)」といった関数が、いま表示されているドキュメントの続きををよしなに判断して取得します。このようにFirestoreのSDKを使うことで、他のクライアントがコレクションに新たなドキュメントを追加したり、既存のドキュメントを削除したりする場合にも、SDKがよしなに差分データだけを取得して画面に反映してくれるため、開発者は難しいことを考えることなくリアルタイムデータベースの効率的で高度な機能を実装できます。</li>
<li>例えばFlutterでは、「Firestore.instance.collection(&#39;コレクション名&#39;).snapshots()」といった関数でストリーム型でデータを取得し、ListViewやGridViewで表示させることでペジネーションの実装が可能です。</li>
</ul>
<h2 is-upgraded>8. トランザクション処理</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/dOVSr0OsAoU?cc_load_policy=1<p>dOVSr0OsAoU</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>Firestoreはトランザクション処理を実現します。例えば、顧客ドキュメントの名前フィールドを更新する際、レビュードキュメント上においたレビューを追加した顧客名も同時に更新しなければならないことがあります。このような場合、一連の更新作業はひとつのトランザクションとし、すべてが成功した場合にのみ更新を確定（コミット）するといった機能が必要です。そうしなければ、途中の更新に失敗した場合データに不整合が発生してしまいます。</li>
<li>Firestoreにおけるトランザクションの考え方には以下の2種類があります。</li>
</ul>
<ol type="1" start="1">
<li>バッチ書き込み：複数ドキュメントに同時書き込みを行いたいときクライアントはそれらをまとめて送り、処理中ドキュメントはロックされトランザクションを実現</li>
<li>楽観的平衡性制御：特にモバイルデバイスでは急なネットワーク停止がありうるため、クライアントからのロック指示は行わず、読み込み→書き込み→読み込み→一貫性チェック→コミットといった順でトランザクション処理を行います。失敗の際は、データベースはロールバックし、クライアント側は再実行で対応します。</li>
</ol>
<ul>
<li>トランザクション対応機能として、ドキュメントに数値フィールドを持ち、その増加と減少にトランザクション処理を施したい場合、FieldValue.increment()を使うと簡単にトランザクションを担保できます。</li>
</ul>
<p>参考）</p>
<ul>
<li>オフィシャルドキュメント：<a href="https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ja" target="_blank">https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ja</a>i</li>
<li>Firestoreでのトランザクションの考え方、必要性：<a href="https://qiita.com/1amageek/items/2eff436fb69bea5875ea" target="_blank">https://qiita.com/1amageek/items/2eff436fb69bea5875ea</a></li>
<li>FieldValue.increment()による高速トランザクション：<a href="https://qiita.com/1amageek/items/665df5a6d9921319e300" target="_blank">https://qiita.com/1amageek/items/665df5a6d9921319e300</a></li>
</ul>
<h2 is-upgraded>9. オフラインサポート</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDvdAFP6OhQ?cc_load_policy=1<p>oDvdAFP6OhQ</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>Firestoreはオフラインをサポートしており、クライアント側にFirestore SDKを使うとオフライン時の読み込みはキャッシュが使われ、書き込みもローカルに保存されオンラインになったら順番にFirestoreに反映されるといったことが実現可能です。</li>
<li>これらの機能は大変高度なものであり、実装するには大変な工数がかかり考慮点も多数ありますが、Firestoreではデフォルトでこれらの機能が利用できますです。</li>
</ul>
<h2 is-upgraded>10. リアルタイムか一括フェッチか？</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/3aoxOtMM2rc?cc_load_policy=1<p>3aoxOtMM2rc</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>リアルタイムデータベースの操作について下記の迷信がありますが、Firestoreはこれらの迷信を覆します。そのためFirestoreにおいてはデフォルトでリアルタイム機能を使うよう設計し開発をすすめることをおすすめします。</li>
</ul>
<ol type="1" start="1">
<li>コーディングが難しい</li>
</ol>
<p>いいえ。Firestore用SDKがストリーム処理をしてくれるので使い方を覚えれば実装は簡単です。</p>
<ol type="1" start="2">
<li>リアルタイム処理だと読み込み数が増え課金が増える</li>
</ol>
<p>いいえ。更新された分だけが読み込み数にカウントされ、むしろ全部を読み込む方式の方が課金されます。リアルタイム処理の方が一般的に課金が少なくなります。</p>
<ol type="1" start="3">
<li>デバイスの電力消費が大きい</li>
</ol>
<p>いいえ。リスナーを常駐させることは電力消費を増やしません。</p>
<h2 is-upgraded>11. サーバレスの概要（Cloud Functions）</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/rERRuBjxJ80?cc_load_policy=1<p>rERRuBjxJ80</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>Firesoteは、Firebase上のドキュメント型リアルタイムデータベースを提供するサービスであり、リレーショナルデータベースをモバイルアプリから利用する際に通常必要となるAPIの開発を必要としません。しかし、異なるドキュメントに重複して所有されるフィールドの更新時に一貫性を持たせるための更新処理を実行したい場合や古いデータをまとめて削除するといった運用バッチを実行したい場合など、バックエンドでまとめて処理を行いたいといった要望があります。</li>
<li>Firebaseでは、そのような場合に利用できる機能としてFirebase Functionsというサービスを提供しています。また、Firebase Functionsは一過性のバッチ処理を実行するものであるため、コンピュータ上にプロセスが常駐しないサーバレス型で実装されています。そのため、使った分だけの課金であるのはもちろん、プロセスの常駐に必要なCPUやメモリ、ストレージへの課金がまるまる削減されます。</li>
<li>Firebase Functionsでサポートされるプログラミング言語はJavaScriptとTypeScriptですが、バグを防ぐためにも型の定義がしっかりしているTypeScriptの利用がおすすめでJavaScriptに似た言語のため言語の習得も容易です。</li>
<li>Firebase Functionsは想定通り動作することを担保するために結合テストを自動化するよいでしょう。その場合、Firebaseエミュレータを使ってFirestoreのエミュレータとつなげてテストすることをおすすめします。そうすれば、自動テストのために課金が発生するといったことを避けられます。</li>
<li>Firebase Functionsの詳細については、下記の動画「TypeScriptを使ってCloud Functionsを始めよう」も参照するとよいでしょう。</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=DYfP-UIKxH0" target="_blank">https://www.youtube.com/watch?v=DYfP-UIKxH0</a></p>
<h2 is-upgraded>12. Cloud Functionsの5つの利用パターン</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/77XmRDtOL7c?cc_load_policy=1<p>77XmRDtOL7c</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<ul>
<li>Cloud Functionsをどのような場合に利用すればよいか、5つのパターンにまとめると以下の通りです。ただし繰り返しになりますがリアルタイムデータベースのメリットが享受できなくなる欠点があることは考慮すべきでしょう。</li>
</ul>
<ol type="1" start="1">
<li>セキュリティルールを単純化したい場合：複雑なアクセスが関数にまとめられるのでセキュリティルールにこれを指定することでことたります。</li>
<li>分散データを更新したい場合：例えば、顧客の名前フィールドを更新するとき、同時にレビュー上の編集者の名前フィールドも更新しなければならない場合、Cloud Functionsで更新することで一貫性を保つことができます。</li>
<li>定期メンテナンスを行いたい場合：日次でメンテナンス用のcronを実行するようなイメージです。例えば、レストランの星の数の平均を日次で計算してレストランの平均星の数フィールドに更新をかける、といったものです。</li>
<li>レガシーデータベースとの連携：レガシーなデータベースが別にあり、Firestoreにデータをレプリケーションしてアプリの読み取り用に使う、といったケースです。</li>
<li>カスタムAPIの作成：用途限定でCloud Functionsを作成するとクライアントアプリの実装がシンプルになり効率化するといったメリットがありえますが、オフライン機能が失われるといったデメリットとのトレードオフを考慮して採用を決めるとよいです。</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Flutterによるアプリ開発" duration="0">
        <p>あああ。</p>
<h2 is-upgraded>開発するアプリケーション</h2>
<br><iframe width="400" height="600" src="https://david3080.github.io/auth/build/web/index.html" frameborder="1"></iframe>
<h2 is-upgraded>初期設定</h2>
<p>あああ</p>
<h3 is-upgraded>Flutterのインストール</h3>
<p><a href="https://flutter.dev/docs/get-started/install" target="_blank">https://flutter.dev/docs/get-started/install</a></p>
<h3 is-upgraded>VS Codeのインストール</h3>
<p><a href="https://flutter.dev/docs/get-started/editor?tab=vscode" target="_blank">https://flutter.dev/docs/get-started/editor?tab=vscode</a></p>
<h2 is-upgraded>Flutterプロジェクトの作成</h2>
<p>あああ</p>
<h3 is-upgraded>Flutter Webの設定</h3>
<h3 is-upgraded>Flutterプロジェクトの作成と実行</h3>


      </google-codelab-step>
    
      <google-codelab-step label="Firebaseのセットアップ" duration="0">
        <p>あああ。</p>
<h2 is-upgraded>Firebaseプロジェクトの作成</h2>
<p>あああ</p>
<h2 is-upgraded>メール/パスワード認証の有効化</h2>
<p>あああ</p>
<h2 is-upgraded>Firestoreデータベースの作成</h2>
<p>あああ</p>
<h2 is-upgraded>Firebase CLIのインストールと設定</h2>
<p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Firebase Authを使ったFlutterアプリ開発" duration="0">
        <p>あああ</p>
<h2 is-upgraded>FlutterプロジェクトでのFirebaseの初期化</h2>
<p>あああ</p>
<h2 is-upgraded>FirebaseのWebアプリ登録とFlutter Webでの初期設定</h2>
<p>あああ</p>
<h2 is-upgraded>Firebase Authを使ったログイン開発</h2>
<p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Firestoreを使ったFlutterアプリ開発" duration="0">
        <p>あああ</p>
<h2 is-upgraded>Flutterアプリ起動時の初期データ登録の開発</h2>
<p>あああ</p>
<h2 is-upgraded>ログインユーザのプロフィール画面の開発</h2>
<p>あああ</p>
<h2 is-upgraded>レストランリスト表示画面の開発</h2>
<p>あああ</p>
<h2 is-upgraded>レストラン詳細画面とレビューリスト画面の開発</h2>
<p>あああ</p>
<h2 is-upgraded>レビュー登録画面と編集画面の開発</h2>
<p>あああ</p>
<h2 is-upgraded>レストラン平均星数登録のトランザクション処理</h2>
<p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="セキュリティルールの作成とデプロイ" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="UnitテストとWidgetテスト" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Firebaseによる運用保守" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="まとめ" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
