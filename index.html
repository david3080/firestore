
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Cloud Firestore</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="./codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="cloud-firestore"
                  title="Cloud Firestore"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="はじめに" duration="0">
        <h2 is-upgraded>本書の目標</h2>
<p>ここでは、<a href="https://firebase.google.com/docs/firestore/" target="_blank">Cloud Firestore</a>の概要を学び、レストランにレビューを追加するアプリを開発するハンズオンを行います。</p>
<p class="image-container"><img style="width: 460.50px" src="img/a3f2c1f577cb3f76.png"></p>
<h2 is-upgraded>学ぶこと</h2>
<ul>
<li>NoSQLデータベースとCloud Firestoreの概要</li>
<li>Cloud Firestoreへのデータ書き込みと読み込み</li>
<li>Cloud Firestore上のデータ更新に対するクライアント側のリアルタイム処理</li>
<li>Firebase認証とCloud Firestore上のセキュルティ・ルール</li>
<li>複雑なCloud Firestoreクエリ</li>
</ul>
<h2 is-upgraded>必要なこと</h2>
<p>ハンズオンを始める前に下記のものをインストールしておくこと</p>
<ul>
<li><a href="https://nodejs.org/ja/" target="_blank">Node.js</a> の <a href="https://www.npmjs.com/" target="_blank">npm</a> （Node v8が推奨バージョン）</li>
<li><a href="https://www.jetbrains.com/webstorm" target="_blank">WebStorm</a>, <a href="https://atom.io/" target="_blank">Atom</a>, <a href="https://code.visualstudio.com/" target="_blank">VS Code</a>, <a href="https://www.sublimetext.com/" target="_blank">Sublime</a> といったエディタ</li>
</ul>
<aside class="warning"><p><strong>ノート: </strong>Node.js は開発中にアプリを実行しテストするのに必要であるが、最終的なアプリはNode.jsには依存せず、ブラウザ上のJavaScriptとして実行されます。</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="NoSQLとFirestoreについて" duration="0">
        <p>NoSQLデータベースの説明からFirestoreの説明までしてくれる12コマの動画シリーズをベースにFirestoreについて説明します。各動画の解説は動画の内容にそったものになっていますが、独自の説明方法を採用している点ご了承ください。</p>
<h2 is-upgraded>動画の全体像</h2>
<p>本動画シリーズは、GoogleのTodd Kerpelman氏による「<a href="https://www.youtube.com/playlist?list=PLl-K7zZEsYLluG5MCVEzXAQ7ACZBCuZgZ" target="_blank">Get to know Cloud Firestore</a>」というFirestoreを使い始めるにあたって知っておくべきことを12回にわたって解説しているものです。動画は画面にiframeで添付されていますが、全画面表示にして参照するとよいです。また字幕を自動表示しますが、英語が苦手な人はYoutube画面の右下の字幕をONにして、さらに設定から字幕の自動翻訳を選び、日本語を選択して日本語字幕を表示して動画を参照するとよいでしょう。</p>
<h2 is-upgraded>1. NoSQLの特徴</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/v_hR4K4auoQ?cc_load_policy=1<p>v_hR4K4auoQ</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>従来型のリレーショナルデータベースでは、テーブルのスキーマが厳格に決められており、正規化という手法でデータの重複が発生しないようテーブル分割します。分割されたテーブルが互いに関係を持つ場合、一方のプライマリキーを他方が外部キーとして持つことで1対多の関係を構成します。例えば「レストラン」と「顧客」と「顧客によるレストランのレビュー(以下、レビュー)」の3つテーブルがあるとして、「レビュー」は「レストラン」と「顧客」を外部キーとして持つことで、「レビュー」テーブルが「レストラン」と「顧客」の間の中間テーブルとして機能します。</p>
<p class="image-container"><img style="width: 549.00px" src="img/2a96ff527bc001a2.png"></p>
<p>一方、NoSQL型データベースは様々なタイプがあるものの、主に「スキーマレス」という特徴を持ち、テーブル定義のような厳格なスキーマをあらかじめ要求しません。NoSQL型データベースでもリレーショナルデータベースのときと同じようにテーブル間のリレーションは重要概念で、上図のようなテーブル間の関係を設計してからアプリケーションのモデル部分を開発する必要がありますが、「スキーマレス」の特徴のため、アプリケーションのリリース後にテーブルに新たなフィールドを追加したくなった場合はアプリのモデル部分に追加するだけでよく、リレーショナルデータベースの時代のようにデータの移行を考慮しながらデータベースに対してスキーマ定義を更新するといった作業が必要なくなります。</p>
<p>また、NoSQL型データベースにはSQL文がありません。例えばコレクションとドキュメントのツリー構造からなるドキュメント型データベースでは、ドキュメントの階層をたどって検索を行うことで目的のドキュメントにたどりつきます。そのため、一つの検索で目的の情報にたどり着くためにわざわざ複数の階層のドキュメントを参照することを避けるため、リレーショナルデータベースでは正規化して別のテーブルに分離したフィールドを、NoSQL型データベースではあえて親子のドキュメント間で重複して持つといった非正規化を行うことが場合によっては推奨されます。例えば、レストランのレビューをリスト表示する場合で考えると、レビューにそれを行った顧客の名前をのせておくと、アプリは顧客までたどることなくレビューだけを検索するだけですみます。</p>
<p>ただしデータの重複保存は表示の際の検索回数を削減できますが、データの一貫性担保に注意が必要です。重複しているフィールドの更新や削除の際、重複して保存された箇所すべての更新や削除を行うことを忘れないようにしてください。これらデータの重複保存の設計は、参照の頻度と更新や削除の頻度のトレードオフを考慮して行います。</p>
<p>以上のとおり、リレーショナルデータベースとNoSQL型データベースにはそれぞれ利点と欠点がありますが、NoSQL型データベースの大きな利点として水平スケーリングが可能ということが挙げられます。この特徴により、アプリが人気になって、データアクセス数やデータ量が大きく増加した場合、NoSQLだとサーバを増強するだけで対応でき、自動スケールが可能になり、運用保守の人件費やシステムの停止リスクが削減できます。いままでデータベースにおいてもっとも大切と言われてきたデータの一貫性担保を一部犠牲にしたとしても、最近NoSQLが流行ってきている理由には、クラウド時代におけるスケーラビリティの必要性が挙げられるわけです。</p>
<p>Cloud Firestoreでは、NoSQL型データベースの中でもドキュメント型データベースを採用しています。ドキュメント型データベースでは、コレクションとドキュメントのツリー構造で構成され、JSONの配列とオブジェクトで表現することができます。これらコレクションとドキュメントの説明は、<a href="https://cloud.google.com/firestore/docs/data-model?hl=ja" target="_blank">Firebaseのデータモデル</a>を参照してください。</p>
<h2 is-upgraded>2. クエリによる検索</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/Ofux_4c94FI?cc_load_policy=1<p>Ofux_4c94FI</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>データベースに検索を行ってデータを取得する操作のことをクエリと呼びます。一般的なドキュメント型データベースでは、一回のクエリの検索対象となるデータの範囲は、検索対象ドキュメントが所属するコレクション内のみになります。以前に説明したコレクションとドキュメントの関係を思い出してもらいたいのですが、コレクションはドキュメントを含みますが、ドキュメントに直接ドキュメントを紐づけることはできず、必ずコレクションを挟みます。例えばレストランのレビューのケースのレストランとレビューの関係は下図のようになります。</p>
<p class="image-container"><img style="width: 455.00px" src="img/bc1fabf08c4bb23e.png"></p>
<p>ここで注目してもらいたいのが各レビュー・コレクションはそれぞれのレストラン・ドキュメントに紐づいているので、すべてのレビューを対象に例えば星4以上など星の数を指定して一括検索することができません。この理由としては、NoSQLデータベースの特徴と言えますが、上のようなツリー構造のため、ドキュメントのインデックスはドキュメントを含むコレクション単位ではられるためと言えます。そのため、同じレビューだからといって隣のコレクションも含めて検索しようとしてもそれは対象外となるわけです。これはSQLではできたことで、レビュー・テーブルを正規化して一つに集めていたため、これらをまとめてインデックス化を行うことができたわけです。</p>
<p>そこで、Firestoreではコレクショングループという機能を用意しています。サブコレクション（上図のレビュー・コレクションに相当）において検索キーとして機能させたいフィールド（上図ではレビュー・コレクションの星の数フィールド）を指定することでこれが可能になります。ただし、Firestoreでは、このコレクショングループが指定できるフィールド数は200個までという制限があることに注意してください。また、Firestoreデータベースツリー内に同じ名前のコレクションが複数あると、それら全てを含めてインデックス化してしまうことに注意が必要です。そのため、一つのFirestoreデータベースで利用するコレクション名は重複しないよう設計しましょう。</p>
<p>Firestoreはドキュメント内のすべてのフィールドが（マップ内のフィールドも含めて）自動的にインデックス化されるので、値の全文一致や上方一致、数値の大小で検索することは非常に高速で行えます。一方、SQL文の&#34;LIKE %(値)%&#34;のような部分一致を行う機能を持っていないので、下記のリンクで行っているような工夫が必要です。</p>
<p><a href="https://qiita.com/oukayuka/items/d3cee72501a55e8be44a" target="_blank">https://qiita.com/oukayuka/items/d3cee72501a55e8be44a</a></p>
<p>またFirestoreの別の制限として&#34;!=&#34;が含まれるクエリや論理ORのクエリを行うことができません。例えば、星の数が満点5だけど書き込み数が少ないとあやしいので、それらを除外する検索条件として「星の数が4以上5より少ない、もしくは、星の数が5でレビュー数が3以上のレビュー」を検索したいとしてもFirestoreではそれができず、「星の数4以上5より小さいレビュー」と「星の数5でレビュー数が3以上」を検索して、クライアント側でマージして、もし重複分があればそれを差し引きしなければなりません。もしくはこの検索条件を見越して新しいフィールド「満点疑惑」といったものを追加して、レビュー書き込み時に星の数5でレビュー数2以下の場合falseに設定し、検索時には星の数が4以上かつ「満点疑惑」がtrueを検索するよう実装する、といった工夫が必要です。</p>
<p>さらにFirestoreのクエリで注意が必要なケースとして「複合クエリ」が挙げられます。複合クエリとはwhere文を複数つないでAND検索を行うことをあらわしますが、このとき複数種類のフィールドで範囲比較（&#34;&lt;&#34;, &#34;&lt;=&#34;, &#34;&gt;&#34;, &#34;&gt;=&#34;）またはarray-contains句を適用する場合は、それら複数フィールドの組み合わせでインデックスを作成しておく（これを複数インデックスと呼ぶ）必要があります。あらかじめオブジェクトのすべてのフィールドの組み合わせで複合インデックスを作っておくという案も考えられるが、これらの組み合わせは莫大な量になりうるため、検索の要件にあわせて複合インデックスを行うことにします。</p>
<p>Firestoreの便利な機能としては、もしこの複合インデックスの設定をおこたった状態でクライアントから複合クエリを実行した際、エラーメッセージがFirestore上の複合インデックス作成画面へのURIを返してくれるので、そのリンクをたどって設定を行うことができます。</p>
<p>また、範囲比較またはarray-contains句で行う複合クエリの対象フィールドが3種類以上の場合も、これらをまとめて複合インデックスの設定を行います。</p>
<p>以上を踏まえた上で、Firestoreのクエリについてさらに確認したい場合は、下記のオフィシャルドキュメントを参照してください。</p>
<p><a href="https://firebase.google.com/docs/firestore/query-data/queries" target="_blank">https://firebase.google.com/docs/firestore/query-data/queries</a></p>
<h2 is-upgraded>3. コストの考え方</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/6NegFl9p_sE?cc_load_policy=1<p>6NegFl9p_sE</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Firestoreでは、ドキュメントの読み込み数(10万回あたり0.06ドル)、ドキュメントの書き込み数(10万回あたり0.18ドル)、ドキュメントの削除数(10万回あたり0.02ドル)といったドキュメントの処理数単位で課金がなされます。Firestoreではインデックスを元に操作が行われ、条件にあったドキュメントの読み書き削除の際、インデックスを使って対象のドキュメントに一発でたどり着ける（逆にいうとこれしかできない）ため、このような回数による課金が可能になっているものと思われます。</p>
<p>このような課金システムの場合、リスト画面の更新を行う際、リクエストレスポンス型のアクセスを行うと、データベース上のデータ更新部分が一部であったとして、更新されてないものも含め表示対象の全データをまとめて読み込むことになるのでコスト的に大変効率が悪くなります。このあとペジネーションのところで説明しますが、Firestoreでは、データアクセスをリアルタイムデータベースとのストリームとして扱い、クライアント側のキャッシュを有効利用して更新が発生したデータのみをやりとりします。これによって差分の読み書き分だけが課金され、全データ取得型より大幅にコストを削減することができます。</p>
<p>さらに、Google Cloud ConsoleのApp Engine画面にて、Firestoreの利用量と時間ごとの課金料金を確認することができます。また、利用料金の閾値を設けてそれを超えたらアラートメールを送ってくれるような設定を行うこともできますのでうまく運用保守で利用するとよいでしょう。</p>
<h2 is-upgraded>4. マップと配列とサブコレクション</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/o7d5Zeic63s?cc_load_policy=1<p>o7d5Zeic63s</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 is-upgraded>Firestoreにおけるルール</h3>
<p>Firestoreでは、JSONの構造における配列（[]で表す）とマップ（{}で表す）をドキュメント型リアルタイム・データベースとしてうまく操作できるようコレクション（JSON内の配列に相当）とドキュメント（JSON内のマップに相当）にうまく分離して保存管理するよう設計します。この設計をうまく行うためにはFirestoreにおけるいくつかのルールを理解しておく必要があります。</p>
<p><strong>ルール1: ドキュメントには制限がある</strong></p>
<ol type="1" start="1">
<li>1ドキュメントあたり1MB制限あります。そのため、画像ファイルなど大きなファイルはFirebase firestorageに置きファイルパスをドキュメントに保存することで回避します。</li>
<li>1ドキュメントあたり2万フィールドまでの制限があります。普通1ドキュメントにそんなに大量のフィールドは必要ないですが、例えばレストラン・ドキュメントにレビューデータも含めるといった設計をすると、レビューデータが膨れ上がってこの制限を超えてしまうといったことがありえます。ドキュメント内のフィールドは書き込みや更新があるとその都度インデックス処理が走りますが、フィールド数が多すぎるとその処理にオーバーヘッドがかかってしまうという理由からもこの制約が設けられています。以上の理由からも、レビューのように1ドキュメントの配下に大量の配列がぶら下がるような構成の場合は、配列をコレクションとして分割するようにします。</li>
<li>1ドキュメントあたり書き込み回数は1秒間に1回のみという制限があります。異なるドキュメントへの書き込みは並列処理ができますが、同一ドキュメントへの複数からの同時書き込みはできず1秒間に1回のみで、二つ目の処理は失敗するのでクライアント側は再試行する必要があります。</li>
</ol>
<p><strong>ルール2: 検索結果はドキュメント全体が出力される</strong></p>
<p>アプリ表示のときタイトルだけ欲しいケースがありますが、ドキュメント内の一部のフィールドだけを取得することはできず全フィールドデータが送られてきます。これを回避したければドキュメントを分割する必要があります。同じことはセキュリティルールにも言え、ドキュメント内の一部のフィールドだけ異なるアクセス権を付与するといった操作はできません。異なるセキュリティルールを設定したい場合、たとえドキュメント内で配列構造を持たない箇所でもコレクション配下の1ドキュメントとして分割して対応します。</p>
<p><strong>ルール3: 検索対象は浅い</strong></p>
<ul>
<li>一度のクエリでは、データベース全体でなくコレクション内のドキュメントだけが検索対象となります。そのため、レビュー・リストに投稿した顧客名を表示したいような場合は、顧客ドキュメントの名前フィールドの情報をレビュー・ドキュメントにも用意する、といった非正規化が効果的となるでしょう。</li>
<li>2019年からコレクショングループの機能が追加され、「collectionGroud(&#34;コレクション名&#34;).where(...).getDocument)」といったクエリを使って子の情報から親を検索できるようになりました。</li>
</ul>
<p><strong>ルール4: 課金はドキュメントの読み書き回数でカウントされる</strong></p>
<ul>
<li>Firestoreでは前述したとおりドキュメントの読み込みおよび書き込みの回数の合計で課金される金額が決まります。</li>
<li>ルール3のため、一度に表示したい情報が複数ドキュメントに分割されていると、一つにまとまっているよりも数倍の読み込みが発生して課金が発生しますので注意が必要です。</li>
<li>ただし、トランザクション数が少なく課金への影響が少額である部分の設計や実装にこだわるのは、設計者や開発者、運用者の人件費を考えると逆に無駄なことになりうることも念頭におくとよいでしょう。</li>
</ul>
<p><strong>ルール5: 配列操作は奇妙である</strong></p>
<ul>
<li>例えば、arr: [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]という配列は要素arr[1]を削除すると[&#39;a&#39;,&#39;c&#39;]に変わるが&#39;c&#39;に注目して考えるとarr[2]だったものがarr[1]に変わってしまう。</li>
<li>配列要素に追加や削除があると、複数人でデータを扱う際一元的にデータ参照できないという問題がある。</li>
<li>解決策としては、オブジェクトはコレクションIDを使って更新・削除を行う。</li>
</ul>
<p>参考）<a href="https://firebase.googleblog.com/2014/04/best-practices-arrays-in-firebase.html" target="_blank">https://firebase.googleblog.com/2014/04/best-practices-arrays-in-firebase.html</a></p>
<h2 is-upgraded>5. データ構造</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/haMOUb3KVSo?cc_load_policy=1<p>haMOUb3KVSo</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>ドキュメント型データベースにおいて、ユースケースに適したデータ構造を設計するとき主に以下の3種類の構造から適切なものを選ぶと良いでしょう。</p>
<ol type="1" start="1">
<li>一つのドキュメント内に配列もしくはマップとしてオブジェクトを含める</li>
</ol>
<p>例えば、レストラン・ドキュメントに最も星の数が多い5つのレビュー内容や最新の5つのレビュー内容をマップか配列として含めるといったケースに用いられます。</p>
<p>この利点としては、ドキュメントの一度の検索で表示すべき情報を取得することができることが挙げられます。</p>
<p>一方、制約事項としては、データが時間経過とともに拡大する場合はリストが大きくなると、更新時のインデックス化に時間がかかったり、1ドキュメントあたり1MBや2万フィールド数の制限に到達してしまうリスクがあります。</p>
<ol type="1" start="2">
<li>オブジェクトをサブコレクションにおさめる</li>
</ol>
<p>例えば、レストランのレビューは、レストランに関する称賛や批評であるわけで、大量の書き込みが行われる可能性もあることからレストラン・ドキュメントのサブコレクションに含めるとよいでしょう。</p>
<p>この利点としては、リストが大きくなっても親ドキュメントのサイズが変わらず、サブコレクションに対してもすべてのクエリ機能を使用でき、複数のサブコレクションにまたがる<a href="https://cloud.google.com/firestore/docs/query-data/queries?hl=ja" target="_blank">コレクション グループ クエリ</a>を発行できます。</p>
<p>一方、制限事項としては、ドキュメントをまたがって検索することが常である場合にも読み込み回数がドキュメント数分発生してしまうことが挙げられます。</p>
<ol type="1" start="3">
<li>オブジェクトをルートレベルのコレクションにおさめる</li>
</ol>
<p>例えば、レビューを書き込む顧客はこのアプリケーションのユーザであり、例えばアプリに出前機能が追加された際にも再利用する必要があるかもしれないため、ルートレベルのコレクションとして整理するとよいでしょう。</p>
<p>この利点としては、ルートレベルのコレクションはリレーショナルデータベースにおける正規化の考え方と同じく再利用しやすい多対多の関係に適しており、アプリの作り方によらずデータの一貫性が保たれ、安心できます。</p>
<p>一方、制限事項としては、データが階層的になっていることから、データベースが拡大するにつれ、データの取得が難しくなる可能性があります。例えば、20才未満の顧客が4以上の星をつけたレストランを検索する、といった操作は難しいため、必要となりそうな検索条件にあわせてレビュー・ドキュメントにも重複して顧客情報を持つよう設計するとよいでしょう。</p>
<p>データ構造については、下記のオフィシャル・ドキュメントも参照するとよいでしょう。</p>
<p><a href="https://cloud.google.com/firestore/docs/concepts/structure-data?hl=ja" target="_blank">https://cloud.google.com/firestore/docs/concepts/structure-data?hl=ja</a></p>
<h2 is-upgraded>6. セキュリティルール</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/eW5MdE3ZcAw?cc_load_policy=1<p>eW5MdE3ZcAw</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Firestoreでは、データベースのツリー構造のドキュメント位置を指定して誰がCRUD（Create:作成、Read:読み込み、Update:更新、Delete:削除）できるかを指定することができます。これらのアクセス権の指定はセキュリティルールといい、拡張子&#34;.rules&#34;のファイルに設計してFirestoreにデプロイして適用します。</p>
<p>データベース内で、フィールドレベルのアクセス権をIF文を使った複雑な条件文と共に直感的にルール化できるのは、リレーショナルデータベースにはない機能です。APIの開発をしなくてもクライアントから共通化されたSDKを使ってリアルタイムデータベースとしてアクセスできる、といったことを含めて、Firestoreはモバイル開発に最適なデータベースのひとつであると言えるでしょう。</p>
<p>このセキュリティルールでは、データベースのルートからのドキュメントへのパスを指定し、ドキュメントは{xxID}や{xxID=**}のようにID名（自由に命名できます）とワイルドカードを使って指定します。ここで{}内で指定した変数名(xxID)はドキュメントをあらわし、そのドキュメントに含まれるフィールドをキーにしてIF文の中でアクセス条件を指定することができます。またルールの中では「get(ドキュメントへのパス)」を指定して、指定したドキュメントのフィールド値にもアクセスできます（例えばログインユーザのロールなど）。</p>
<p>これらのルールは複雑で再利用したくなる場合がありますが、カスタムファンクションといういわゆる関数を定義して、例えばGoogleアカウントかどうかをチェックするといった処理を関数化してルールファイル内で再利用することができます。</p>
<p>セキュリティルールはアクセス権の設定が主な目的ですが、このしくみを使うと書き込みや更新時に空白を受け付けないフィールドを指定したり、メールアドレスの形式のチェック、さらには1顧客が書き込みできるレビューの数を100件までに制限するといったデータバリデータとして利用することも可能です。そのため、プロジェクトごとにどこまでセキュリティルールに設定を行うかをあらかじめ決めておくとよいでしょう。</p>
<p>ルールファイルはアプリ内で想定通り動作することを担保するために単体テストを自動化するよいでしょう。その場合、Firebaseエミュレータを使ってテストすることをおすすめします。そうすれば、自動テストのために課金が発生するといったことを避けられます。</p>
<p>セキュリティルールについては、下記のオフィシャル・ドキュメントも参照するとよいでしょう。</p>
<p><a href="https://cloud.google.com/firestore/docs/security/get-started?hl=ja" target="_blank">https://cloud.google.com/firestore/docs/security/get-started?hl=ja</a></p>
<h2 is-upgraded>7. データのペジネーション</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/poqTHxtDXwU?cc_load_policy=1<p>poqTHxtDXwU</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>一般的に、アプリケーションが表示に必要なレコード以上のデータを取得すると無駄な読み込みに課金が発生しますり、ネットワークを流れるデータ量も増えるため、サーバ側でペジネーションを行うことが推奨されます。Firestoreではストリーミング・データベースとして機能し、高度なペジネーション機能を提供します。というのも、クライアントとストリーミングとしてコネクションを維持している場合、常にクライアント側のキャッシュとの差分をチェックして更新分だけをやりとりしてくれる機能を持っています。また、リストを表示する画面があったとして、画面に表示されていない表の下部や上部をスクロールして表示したいとき、リアルタイムデータベースは画面の移動にあわせて必要なデータをストリーム取得してくれます。具体的には「Query.start(after:previousDoc)」といった関数がいま表示されているドキュメントの続きををよしなに判断して取得してくれます。このようにFirestoreのSDKを使うことで、他のクライアントがコレクションに新たなドキュメントを追加したり、既存のドキュメントを削除したりする場合にも、アプリケーションが表示している画面に集中してリストの更新を行ってくれるため、開発者は難しいことを考えることなくリアルタイムデータベースの効率的で高度な機能を実現するアプリの開発を行うことができます。</p>
<p>例えば、Flutterでは、「Firestore.instance.collection(&#39;コレクション名&#39;).snapshots()」といった関数でストリーム型でデータを取得し、ListViewで表示させることでペジネーションの実装が可能です。</p>
<h2 is-upgraded>8. トランザクション処理</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/dOVSr0OsAoU?cc_load_policy=1<p>dOVSr0OsAoU</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Firestoreでももちろんトランザクション機能を提供しています。例えば、顧客ドキュメントの名前フィールドを更新する際、レビュードキュメント上においたレビューを追加した顧客名も同時に更新しなければならないことがあります。このような場合、一連の更新作業はひとつのトランザクションとし、すべてが成功した場合にのみ更新を確定（コミット）するといった機能が必要です。そうでなければ、途中の更新に失敗した場合データに不整合が発生してしまいます。</p>
<p>Firestoreにおけるトランザクションの考え方は下記の通りです。</p>
<ol type="1" start="1">
<li>バッチ書き込み: 複数ドキュメントに同時に書き込みを行いたいときクライアントはそれらをまとめて送り、処理中ドキュメントはロックされトランザクションを保ちます。</li>
<li>楽観的平衡性制御: 特にモバイルデバイスでは急なネットワーク停止がありうるので、クライアントからのロック指示は行わず、読み込み→書き込み→読み込み→一貫性チェック→コミットといった順で処理指示を行います。失敗したらデータベースはロールバックし、クライアント側は再実行で対応します。</li>
</ol>
<p>また、具体的な機能として、ドキュメントに数値フィールドを持ち、その増加と減少にトランザクション処理を施したい場合、FieldValue.increment()を使うと簡単にトランザクションを担保できます。</p>
<p>参考）</p>
<ul>
<li>FieldValue.increment()による高速トランザクション：<a href="https://qiita.com/1amageek/items/665df5a6d9921319e300" target="_blank">https://qiita.com/1amageek/items/665df5a6d9921319e300</a></li>
<li>Firestoreでのトランザクションの考え方、必要性：<a href="https://qiita.com/1amageek/items/2eff436fb69bea5875ea" target="_blank">https://qiita.com/1amageek/items/2eff436fb69bea5875ea</a></li>
<li>オフィシャルドキュメント：<a href="https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ja" target="_blank">https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ja</a>i</li>
</ul>
<h2 is-upgraded>9. オフラインサポート</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDvdAFP6OhQ?cc_load_policy=1<p>oDvdAFP6OhQ</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Firestoreはオフラインをサポートしており、クライアント側にFirestore SDKを使うと、オフライン時の読み込みはキャッシュが使われ、書き込みもローカルに保存されオンラインになったら順番にFirestoreに反映されるといったことが可能です。これらの機能は大変高度なものであり、実装するには大変な工数がかかり考慮点も多数あるように思えますが、Firestoreではデフォルトでこれらの機能が有効であり、Firestore SDKを使えば簡単に実装することが可能です。</p>
<h2 is-upgraded>10. リアルタイムか一括フェッチか？</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/3aoxOtMM2rc?cc_load_policy=1<p>3aoxOtMM2rc</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>リアルタイムデータベースの操作について下記の迷信がありますが、Firestoreはこれらの迷信を覆します。そのため、Firestoreでは、デフォルトでリアルタイム機能を使うよう設計し開発をすすめることをおすすめします。</p>
<ol type="1" start="1">
<li>コーディングが難しい</li>
</ol>
<p>いいえ、Firestore用SDKがストリーム処理をしてくれるのでお作法を覚えれば実装は簡単です。</p>
<ol type="1" start="2">
<li>リアルタイム処理だと読み込み数が増え課金が増える</li>
</ol>
<p>いいえ、更新された分だけが読み込み数にカウントされ、むしろ全部を読み込む方式の方が課金されることになります。リアルタイム処理の方が一般的に課金がすくなくなります。</p>
<ol type="1" start="3">
<li>デバイスの電力消費が大きい</li>
</ol>
<p>いいえ、リスナーを常駐させることは電力消費を増やしません。</p>
<h2 is-upgraded>11. サーバレスの概要（Cloud Functions）</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/rERRuBjxJ80?cc_load_policy=1<p>rERRuBjxJ80</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Firesoteは、Firebase上のドキュメント型リアルタイムデータベースを提供するサービスであり、リレーショナルデータベースをモバイルアプリから利用する際に通常必要となるAPIの開発を必要としません。しかし、異なるドキュメントに重複して所有されるフィールドの更新時に一貫性を持たせるための更新処理を実行したい場合や古いデータをまとめて削除するといった運用バッチを実行したい場合など、バックエンドでまとめて処理を行いたいといった要望があります。Firebaseでは、そのような場合に利用できる機能としてFirebase Functionsというサービスを提供しています。また、Firebase Functionsは一過性のバッチ処理を実行するものであるため、コンピュータ上にプロセスが常駐しないサーバレス型で実装されています。そのため、使った分だけの課金であるのはもちろん、プロセスの常駐に必要なCPUやメモリ、ストレージへの課金がまるまる削減されます。</p>
<p>Firebase Functionsでサポートされるプログラミング言語はJavaScriptとTypeScriptですが、バグを防ぐためにも型の定義がしっかりしているTypeScriptの利用がおすすめでJavaScriptに似た言語のため言語の習得も容易です。</p>
<p>Firebase Functionsは想定通り動作することを担保するために結合テストを自動化するよいでしょう。その場合、Firebaseエミュレータを使ってFirestoreのエミュレータとつなげてテストすることをおすすめします。そうすれば、自動テストのために課金が発生するといったことを避けられます。</p>
<p>Firebase Functionsの詳細については、下記の動画「TypeScriptを使ってCloud Functionsを始めよう」も参照するとよいでしょう。</p>
<p><a href="https://www.youtube.com/watch?v=DYfP-UIKxH0" target="_blank">https://www.youtube.com/watch?v=DYfP-UIKxH0</a></p>
<h2 is-upgraded>12. Cloud Functionsの5つの利用パターン</h2>
<br><iframe width="560" height="315" src="https://www.youtube.com/embed/77XmRDtOL7c?cc_load_policy=1<p>77XmRDtOL7c</p>amp;cc_lang_pref=ja" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Cloud Functionsをどのような場合に利用すればよいか、5つのパターンにまとめると以下の通りです。</p>
<ol type="1" start="1">
<li>セキュリティルールを単純化したい場合：複雑なアクセスが関数にまとめられるのでセキュリティルールにこれを指定することでことたります。</li>
<li>分散データを更新したい場合：例えば、顧客の名前フィールドを更新するとき、同時にレビュー上の編集者の名前フィールドも更新しなければならない場合、Cloud Functionsで更新することで一貫性を保つことができます。</li>
<li>定期メンテナンスを行いたい場合：日次でメンテナンス用のcronを実行するようなイメージです。例えば、レストランの星の数の平均を日次で計算してレストランの平均星の数フィールドに更新をかける、といったものです。</li>
<li>レガシーデータベースとの連携：レガシーなデータベースが別にあり、Firestoreにデータをレプリケーションしてアプリの読み取り用に使う、といったケースです。</li>
<li>カスタムAPIの作成：用途限定でCloud Functionsを作成するとクライアントアプリの実装がシンプルになり効率化するといったメリットがありえますが、オフライン機能が失われるといったデメリットとのトレードオフを考慮して採用を決めるとよいです。</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Firestoreでのデータモデル設計とチェックリスト" duration="0">
        <p>あああ。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Firebaseプロジェクトの作成とセットアップ" duration="0">
        <p>あああ。</p>
<h2 is-upgraded>Firebaseプロジェクトの作成</h2>
<p>あああ</p>
<h2 is-upgraded>匿名認証の有効化</h2>
<p>あああ</p>
<h2 is-upgraded>Cloud Firestoreの有効化</h2>
<p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="サンプルコードの入手" duration="0">
        <p>あああ。</p>
<h2 is-upgraded>VS Codeへの読み込み</h2>
<p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Firebase CLIのインストール" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="ローカルサーバの実行" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Cloud Firestoreへのデータ登録" duration="0">
        <p>あああ。</p>
<h2 is-upgraded>データモデル</h2>
<p>あああ</p>
<h2 is-upgraded>レストランデータの追加</h2>
<p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Cloud Firestoreから読み込んだデータ表示" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="get()関数によるデータ読み込み" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="データのソートとフィルタ" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="インデックスのデプロイ" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="トランザクションを使ったデータ更新" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="セキュリティ・ルールのデプロイ" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
      <google-codelab-step label="最後に" duration="0">
        <p>あああ</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
